machine-teaching
================
機械学習システム構築のための新しいパラダイム

---

機械学習システムを構築するための現在のプロセスは、機械学習についての深い知識を有する実務者を必要とする。 これにより、作成できる機械学習システムの数が大幅に制限され、機械学習システムの需要と組織がそれらを構築する能力との間に不一致が生じています。 機械学習システムに対するこの高まる需要を満たすためには、機械を教えることができる個人の数を大幅に増やす必要があると考えています。 私達は私達が機械を教えるプロセスを簡単に、速くそして何よりも、普遍的にアクセス可能にすることによってこの目的を達成することができると仮定する。

機械学習は新しいアルゴリズムの作成と「学習者」の正確性の向上に重点を置いていますが、機械教育分野は「教師」の有効性に重点を置いています。 専門分野としての機械教育は、ソフトウェア工学およびプログラミング言語の原則に従って拡張するパラダイムシフトです。 私たちは、教師と教師のデータとの相互作用、ならびに対話や視覚化の技法や設計原則などの重要な要素に重点を置いています。

本稿では、機械教育の規律に関する私たちの立場を提示し、基本的な機械教育の原則を明確にします。 また、機械学習アルゴリズムに関する知識を教育プロセスから切り離すことによって、革新を加速し、機械学習モデルの何百万もの新しい用途に力を与える方法についても説明します。

キーワード：機械教育、機械学習、プログラミング、ソフトウェア工学、概念分解、教育理念、教育プロセス、機械学習の民主化、

---

## 1 INTRODUCTION

機械学習（ML）モデルの需要は、それらのモデルを構築することができる「機械教師」の供給をはるかに超えています。コンピュータで自動化したい常識理解タスクのカテゴリには、コマンドの解釈、カスタマーサポート、または 私たちに代わってタスクを行うエージェントがある。 カテゴリ、ドメイン、およびタスクの組み合わせにより、特殊な高精度の機械学習モデルを構築するための何百万という機会が生まれます。 たとえば、テレビを制御するための音声コマンドを理解するためのモデルを構築したり、レストランを予約するためのエージェントを構築することに関心があるかもしれません。 多くの人にソリューションの幅を広げるための鍵は、機械を教えるプロセスを簡単、迅速、そして普遍的にアクセス可能にすることによって、機械教師の数を増やすことです。  
 機械学習コミュニティの大部分は、精度を向上させるための新しいアルゴリズムの作成に焦点を当てています。
特定のラベル付きデータセットに対する「学習者」（機械学習アルゴリズム）の影響 「機械教育（MT）」の分野は、学習者に与えられた教師の有効性に焦点を当てています。 機械教育の測定基準は、生産性、解釈可能性、堅牢性、問題の複雑さや貢献者の数によるスケーリングなど、人件費に関連したパフォーマンスを測定します。  
 モデル構築の生産性に影響を与える多くの問題は、従来の機械学習では対処できません。 そのような問題の1つは概念進化であり、これは教師のターゲットクラスの基本概念が時間の経過とともに定義され洗練されるプロセスです[Kulesza et al。 2014]。 ラベルのノイズや不一致は、ターゲットの概念が固定されており、ラベルによって定義されていることを前提としているため、従来の機械学習には不利です。 実際には、概念定義、スキーマ、およびラベルは、レアポジティブの新しいセットが発見されたとき、または教師が単に考えを変えたときに変わる可能性があります。

 機械学習者と機能セットが固定されているガーデニングWebページのバイナリ分類タスクを取り上げましょう。 教師は最初に植物園のウェブページにガーデニングのコンセプトの良い例としてラベルを付けるかもしれませんが、後でそれらが悪い例であると判断します。 目標概念が進化したときに例を再ラベルすることは、教師にとって大きな負担です。 教師の観点からは、概念はサブ概念に分解可能であるべきであり、サブ概念間の関係の操作は簡単で、解釈可能で、そして可逆的であるべきです。 副概念としての植物園の開始時に、教師は植物園を含むその副概念に園芸を分解し、この新しい概念図に従ってWebページにラベルを付けることができます。  
 このシナリオでは、サブ概念のラベリングは、ターゲット概念モデルを構築する機械学習アルゴリズムには利点がありませんが、概念操作を有効にすることで教師に役立ちます。 下位概念の操作は一定の時間で行うことができ、教師の意味決定はコミュニケーションとコラボレーションのために文書化することができます。 概念の進化に取り組むことは、教師の視点に重点を置くことがモデル構築の生産性に大きな違いをもたらす可能性があることのほんの一例です。  

 機械教育は、機械学習から離れたパラダイムシフトであり、プログラミング言語の他の分野が、関数型プログラミング、プログラミングインタフェース、バージョン管理などの概念を用いてパフォーマンスの最適化から生産性の最適化にどのように移行したかに似ています。 ソフトウェア生産性の基本であるソフトウェア工学と言語の原則。 機械教育では、教師と教師のデータとの相互作用に重点が置かれています。相互作用と視覚化の手法と設計原則は非常に重要な要素です。 機械教育は、基礎となるアルゴリズムと教育言語との間の抽象化およびインターフェースを定義するため、機械学習の基礎にも直接関係しています。 したがって、機械教育は、人間とコンピュータの相互作用、機械学習、視覚化、システム、およびエンジニアリングの分野の相互作用に基づいています。

このホワイトペーパーの目的は、教師の視点から機械学習モデル構築を探求することです。

## 2 新しい学問領域の必要性

 2016年、マイクロソフトの社内カンファレンス（TechFest）で、「どのようにして機械学習システムを構築および維持するのですか」というパネルで、主催者は「最悪の悪夢は何ですか？」と質問してディスカッションを始めました。 生産のための機械学習モデルを構築するという文脈で。 ある女性が腕を上げて最初の答えを出しました。

```
「[...]バージョンを管理します。 データバージョンを管理します。 モデルを再現できるように。 データが消え、人が消え、モデルが消えたら、これを再現することはできません。 私はBingでこの何百回も見たことがあります。 私は毎日それを見ました。 いいね…ああ、いいモデルだよ。 わかりました、私はそれを微調整する必要があります。 私はそれを理解する必要があります。 そして……今は再現できません。 それが私の最大の悪夢です！
```

この証言にコンテキストを当てはめるために、機械学習モデルの構築が製品内でどのように見えるかを見てみましょう。
グループ：

* （1）問題のある所有者がデータを収集し、ラベル付けのガイドラインを書き、オプションで一部のラベルを寄付します。
* （２）データの大部分（例えば５万例）のラベル付けは外部委託される。
* （3）問題の所有者はラベルを調べて、ガイドラインが不正確であること、またはサンプリングされた例が問題に不適切または不適切であることを発見する可能性があります。 それが起こるとき、GOTOステップ1。
* （４）ＭＬエキスパートは、アルゴリズム（例えば、ディープニューラルネットワーク）、アーキテクチャ（例えば、層の数、層当たりの単位など）、目的関数、正則化器、交差検証集合を選択するために調べられる。 等
* （5）エンジニアは、パフォーマンスを向上させるために既存の機能を調整するか、または新しい機能を作成しています。 モデルはテストのためにわずかなトラフィックでトレーニングおよび展開されます。
* （6）システムがテストトラフィックでうまく機能しない場合は、手順1に進みます。
* （7）モデルはフルトラフィックで展開されます。 モデルの性能が監視されます。 これは、パフォーマンスがクリティカルレベルを下回るまでの操作手順です。
* （8）運用が開始されたら、システムを監視する必要があります。 修正が必要な場合は、手順1に進みます。

ステップ1から6までの反復には通常数週間かかります。システムはステップ7で数ヶ月間安定している可能性があります。データ配布の変化、競争の激化、要求の高まり、新しい機能の利用、一部の古い機能の利用不可、問題の定義の変更など、さまざまな理由が考えられます。または、セキュリティ更新プログラムなどの理由でコードが破損している。さまざまなステップで、問題の所有者、機械学習の専門家、またはキーエンジニアが別のグループまたは別の会社に移動した可能性があります。機能またはラベルは、バージョン管理も文書化もされていません。データがアドホックで有機的な方法で行われたため、データがどのように収集されたかを理解している人はいません。異なる専門知識を持つ複数のプレイヤーが関わっているため、なぜモデルが再訓練されたときに期待どおりに機能しないのかを理解するには多大な労力と調整が必要です。最悪の場合、モデルは動作していますが、期待どおりに動作しているかどうかを判断することはできません。また、モデルをオフにする責任を誰にも望まないようです。機械学習「ごみ」は至るところに蓄積し始めます。これらの問題は実際には機械学習にとって目新しいものではない[Sculley et al。 2014]。

上記の例は、機械学習モデルの構築は単なるデータおよび学習アルゴリズム以上のものであり、機械学習ソリューションを構築する管理プロセスには非効率性が伴う可能性があることを示しています。現在の機械学習パラダイムに深く埋め込まれている非効率の他の形態があります。たとえば、機械学習プロジェクトは通常、ラベル付きの大きなデータセットでトレーニングされた単一のモノリシックモデルで構成されています。モデルのパフォーマンス指標の要約（精度、F1スコアなど）が唯一の要件であり、パフォーマンスが変わらない場合、新しいモデルが以前に正しく予測された例を誤ったとしても、例を追加することは問題になりません。しかしながら、予測可能性と品質管理が重要である多くの問題のために、モデル品質のどんな否定的な進歩でも全体のモデルの面倒なテストにつながり、そして高い維持費を被ります。単一のモノリシックモデルに頼るだけでは、問題の部分を分離し、回帰の根本的な原因を明確に説明するために必要なモジュール性が欠けます。現在の機械学習パラダイムは、データの可用性と、問題の複雑さが増すにつれてトレーニング分布が実際の分布と一致することに依存しています。ただし、データが不足している場合やいくつかのクラスの例について正当性を保証する必要がある場合は、モノリシックモデルビューでは不十分です。

### 2.1 機械学習と機械教育の定義

上記のような機械学習の問題に取り組むことが、世界で最も優れた機械学習会議において高い優先順位を与えられていると主張することは困難です。 これらの問題と非効率性は、機械学習分野の中心的なトピックである機械学習アルゴリズムから生じるものではありません。 それらは、機械学習を使用するプロセス、人と機械学習アルゴリズムとの間の相互作用、および人自身の制限から生じます。
この主張をより重視するために、機械学習の研究分野を狭く次のように定義します。

定義２．１（機械学習研究） 機械学習研究は、MLアルゴリズムを改良することによって学習者をより良くすることを目的としています。

たとえば、この分野では、ディープラーニング、教師なし学習、リカレントネットワーク、凸最適化などの新しいバリエーションやブレークスルーについて説明します。  

逆に、バージョン管理、概念分解、セマンティックデータの探求、教育言語の表現力、モデルの解釈可能性、そして生産性は、機械学習よりもプログラミングや人間のコンピュータとのやり取りに共通していると考えています。 しかしながら、これらの「機械教育」の概念は、機械学習の実践者にとって非常に重要です。 したがって、これらの概念を改善することを目的とした分野を次のように定義します。

定義２．２（機械教育研究） 機械教育研究は、機械学習モデルの構築において教師をより生産的にすることを目的としています。

2つのフィールド間の共通部分を最小化し、それによって明確さとスコープを提供するためにこれらの定義を選択しました。 2つの分野は補完的であり、独立して進化することができます。 もちろん、他の一般化と同様に、制限もあります。 カリキュラム学習[Bengio et al。 例えば、2009]は、交差点に正直に属するように見受けられるかもしれません、なぜならそれは学習アルゴリズムと教師の行動の両方を含むからです。 それにもかかわらず、我々は何に取り組むべきか、何に取り組まないべきかを決めるのにこれらの定義が有用であることを見出した。

### 2.2 機械学習から機械教育を切り離す

機械教育ソリューションでは、教育プロセス全体（および最終出力）でモデルを作成するために1つ以上の機械学習アルゴリズムが必要です。この要求は教師にとって物事を複雑にする可能性があります。利用可能なリソース（例えば、ＤＳＰ、ＧＰＵ、ＦＰＧＡ、タイトメモリ、またはＣＰＵの制約）、または実装のために実装されてグリーンライトされているものに応じて、異なる展開環境は異なるランタイム機能をサポートし得る。機械学習アルゴリズムは、実行時に利用可能な一連の機能から教示情報をインスタンスに変換する「コンパイラ」です。そのような事例は、ニューラルネットワークにおける重み、Ｋ平均における「平均」、ＳＶＭにおけるサポートベクトル、または決定木における決定によって特徴付けることができる。ランタイム関数の各セットに対して、異なる機械学習コンパイラが利用可能であり（例えば、ＬＢＦＧＳ、確率勾配降下）、それぞれがそれ自身のパラメータのセット（例えば、履歴サイズ、正則化器、ｋ倍、学習率スケジュール、バッチサイズ、等。）  

機械教育は、実行中の変動性と最適化の複雑さの両方から教師を保護することを目的としています。 これにはパフォーマンスが犠牲になります。最適化パラメータの専門的な制御によるターゲットランタイムの最適化は、常に一般的なパラメータのない最適化よりも優れています。 インラインアセンブリコードに似ています。 しかし、高水準プログラミング言語と同様に、機械教育の目標は、メンテナンス時間と必要な専門知識の両方の観点から人件費を削減することです。 教える言語は、ISO C ++の哲学に従って、「一度書いて、どこでもコンパイルする」であるべきです。  

機械学習アルゴリズムの入力（特徴値）および出力（ラベル値）を記述する明確に定義されたインタフェースを使用して、ティーチングソリューションはこれらのインタフェースをサポートする任意の機械学習アルゴリズムを活用することができます。 さらに3つのシステム要件があります。

* （1）教師が利用できる特徴的な言語は、例が意味のある方法で区別されることを可能にするのに十分表現力豊かであるべきである（テキスト文書のハッシュは区別力を有するが、それは意味があると見なされない）。 これにより、教師は必ずしも概念の複雑さを増すことなく、機能の盲目を取り除くことができます。
* （２）システムが返すことができる関数のセットの複雑さ（ＶＣ次元）は、特徴空間の次元と共に増加する。 これにより、教師は特徴を追加することによって近似誤差を減らすことができます。
* （3）利用可能なMLアルゴリズムは、学習の一貫性に関する古典的な定義を満たさなければなりません[Vapnik 2013]。 これにより、教師はラベル付きの例を追加して推定誤差を減らすことができます。

これらの要件の目的は、ランタイム関数空間、学習アルゴリズム、または最適化を理解する必要なしに、教師が任意のレベルの精度で任意の概念関数を作成およびデバッグできるようにすることです。

## 3 プログラミングのアナロジー

このセクションでは、機械を教えることはプログラミングの一種であると主張します。 最初に、機械教育とプログラミングの共通点について説明します。 次に、私たちが主張するソフトウェア開発をサポートするために開発されたいくつかのツールを、機械教育の分野に有益なガイダンスとインスピレーションを提供する可能性が高いと強調します。 この章では、プログラミングの分野の歴史と、それがどのようにして機械教育の分野の軌跡を予測できるのかについて説明します。

### 3.1 プログラミングと教育の共通点と相違点

ソフトウェア技術者が、入力Ｙに対して値Ｘを返すステートレスなターゲット関数を（例えば、関数型プログラミングのように）作成する必要があると仮定する。厳密に逐次的ではないが、プログラミングプロセスを以下のようなステップのセットとして説明できる。

```
（1）対象機能を指定する必要があります
（2）対象となる機能を細分化することができる
（3）機能（サブ機能を含む）のテストとデバッグが必要
（4）機能を文書化できる
（5）機能を共有できる
（6）機能を配置できる
（7）機能を維持する必要がある（予定および予定外のデバッグサイクル）
```

さて、教師が入力Xに対してクラスYを返すターゲット分類関数を構築したいと仮定しましょう。前のセクションで提示された機械教育のためのプロセスは上のプログラミングステップのセットに似ています。 強い類似点がありますが、特にデバッグ手順においては、大きな違いがあります（表1）。

表1.プログラミングと機械教育におけるデバッグ手順の比較

* プログラミングにおけるデバッグ手順
  * （3）繰り返します。
    * インスペクション
    * コード編集
    * コンパイル
    * テスト
* 機械教育におけるデバッグ手順
  * （3）繰り返します。
    * インスペクション
    * 知識（ラベル、機能など）を編集/追加する
    * 学習
    * テスト

教育がプログラミングに完全に類似するためには、機械学習モデル構築タスクの文脈でこれらのステップを表現することを可能にする言語にアクセスする必要があります。 プログラミングに関しては、言語の例は、実行のために機械語にコンパイルすることができるＣ ＋＋、パイソン、ジャバスクリプトなどを含む。 教えるために、言語は機械学習アルゴリズムがトレーニングに活用できる形式に教師の知識を表現する手段です。 教師の知識は、ラベルを提供することに限定される必要はないが、スキーマ制約（例えば、分類のための相互に排他的なラベル、エンティティ抽出における状態遷移制約１）、ラベル付きの例、および特徴の組み合わせであり得る。 現在の限界に対処するために新しいプログラミング言語が開発されているように、教師が異なる種類の知識を伝達し、より効果的に知識を伝達することを可能にする新しい教育言語が開発されることを期待します。

### 3.2 前進する道を切り開くプログラミング

前のセクションで説明したように、現在の機械学習プロセスでは異なる専門知識を持つ複数の人々とそれらの間の強力な知識依存が必要です。データとモデルのバージョン管理の標準やツールはなく、問題形成の間には強い相互依存関係があります 、訓練および基礎となる機械学習アルゴリズム。 幸い、機械教育の新興分野では、プログラミング、ソフトウェア工学、および関連分野から学んだ教訓を活用できます。 これらの分野は過去半世紀にわたって発展してきており、機械教育が解決することを目的としている多くの類似した問題を扱っています。 彼らの強い共通点を考えるとこれは驚くべきことではありません。 このセクションでは、いくつかの教訓を強調し、それらを機械教育に関連付けます。

#### 3.2.1複雑な問題を解決する

プログラミング分野では、ソフトウェアエンジニアが効率的で保守可能で理解しやすいソリューションを可能にする方法で複雑な問題を解決することを可能にする一連のツール、技法、および原則を開発および改善しました。 これらの原則には、問題の分解、カプセル化、抽象化、およびデザインパターンが含まれます。 これらのそれぞれについて議論するのではなく、複雑な問題を解決するソフトウェアエンジニアと複雑な問題を解決する機械教師の間で期待が異なるのは対照的です。 ソフトウェアエンジニアが複雑な問題を解決するシステムを作成できるようにした最も強力な概念の1つは、分解の概念です。 次の逸話はその重要性と力を説明します。

私たちは何十人ものソフトウェアエンジニアに次のことを尋ねました。
* （1）ゲームTetrisを正しく実装するプログラムを書くことができますか？
* （2）一ヶ月でできますか。

最初の質問に対する答えは、普遍的に「はい」です。 2番目の質問に対する答えは、「そう思う」から「2日以上かかるのはなぜでしょうか」までさまざまです。最初の質問は、すべての計算可能な関数がチューリング機械によって計算可能であることを述べている教会 - チューリング論におそらく関係しています。人間がその関数を計算することができれば、チューリング機械上で同じ計算を実行することができるプログラムが存在する。言い換えれば、Tetrisゲームを実装するためのアルゴリズムがあることを考えると、最も尊敬されるソフトウェアエンジニアは、自分がアクセスできるどのマシンでも、慣れ親しんだプログラミング言語でもゲームを実装できると考えています。 2番目の質問に対する答えはもっと不可解です。テトリスゲームの状態空間（非公式には画面上のピースの構成数）は非常に大きく、実際にはソフトウェアエンジニアが調べることができるものよりはるかに大きいです。実際、プログラムの複雑さは、状態空間内の状態の表現と共に指数関数的に増大するはずであると予想するかもしれません。それでも、ソフトウェアエンジニアは、1か月以内にゲームを実装できると確信しているようです。最も可能性の高い説明は、それらが実装の複雑さとデバッグが状態空間の表現と入力の両方において多項式であると考えるということです。

機械学習の専門家が複雑な問題を教えることについて尋ねた同様の質問にどのように反応するかを調べてみましょう。
* （1）あなたがすることと同じように、台所用品を画像で認識する機械を教えることができますか？
* （2）一ヶ月でできますか。

一人の人が躊躇せずに両方の質問に「はい」と答えたが、ほとんどの機械学習の専門家は、「おそらく」、「よくわからない」、「おそらくわからない」、「そう思う」などの答えを持っていました。 Tetrisゲームを実装し、単純で変形不可能なオブジェクトを認識することはどちらの分野でもかなり基本的な機能のように思われるため、両方の質問に対する答えが大きく異なることは驚くべきことです。

プログラミングと教育の両方の目的は、機能を作成することです。 その点で、2つの活動は違いがあるよりもはるかに共通点があります。 どちらの場合も、私たちは機能を書いているので、チャーチ - チューリングの論文が教えることには当てはまらないと考える理由はありません。 類似点があるにもかかわらず、そのような機能の作成、デバッグ、および保守の成功に対する期待は、ソフトウェアエンジニアと教師の間で大きく異なります。 プログラミング言語と教育言語は異なりますが、質問に対する答えはプログラミング言語に関係なくすべてのソフトウェアエンジニアにとって同じでした。 それでも、ほとんどの機械学習の専門家は、問題が解決可能であると考えたとしても、教育の問題を解決するのにかかる時間に上限を設けていません。

問題をより小さな問題に分解することを学びました。 コーディングやデバッグが一定時間または多項式時間で実行できるようになるまで、それぞれの小さな問題はさらに分解できます。 たとえば、Tetrisをコーディングするために、状態モジュール、状態変換モジュール、入力モジュール、スコアリングモジュール、形状表示モジュール、アニメーションモジュールなどを作成できます。 これらの各モジュールはさらに小さなモジュールに分解できます。 小さなモジュールは多項式時間で構成されデバッグされます。 各モジュールを効率的に構築できることを考えると、ソフトウェアエンジニアは、1か月以内にTetrisをコーディングできると確信しています。

問題を分解する能力は習得したスキルであり、習得するのは容易ではないということを観察するのは興味深いことです。 賢い学生は、1〜2週間でプログラミング言語のすべての機能（変数、配列、条件付きステートメント、forループなど）を理解し、学ぶことができます。 同じ学生が2週間後にテトリスをコード化するように頼まれた場合、彼らはどこから始めればよいかわからないでしょう。 プログラミング方法を学んでから6〜12ヵ月後、ほとんどのソフトウェアエンジニアは1ヵ月未満でテトリスのゲームをプログラミングするタスクを受け入れることができるでしょう。

分解がソフトウェアエンジニア2に自信を与え、複雑な問題を解決する上での上限と同じように、機械教師は複雑な機械学習問題を正しいツールと経験で分解することを学ぶことができます。 プログラミングのレベルに匹敵するレベルに。

#### 3.2.2 複数の貢献者へのスケーリング

ソフトウェアエンジニアが解決できる問題の複雑さは、過去半世紀にわたって著しく増加していますが、1人のソフトウェアエンジニアが解決できる問題の規模には限界があります。 これに対処するために、複数のエンジニアが問題の解決に貢献できるようにするための多くのツールおよび技法が開発されています。 このセクションでは、プログラミング言語、インターフェイス（API）、およびバージョン管理という3つの概念に焦点を当てます。

貢献者の数に応じた拡張を可能にする重要な開発の1つは、標準化されたプログラミング言語の作成です。 標準化されたプログラミング言語と設計パターンおよびドキュメンテーションの使用により、他の共同作業者はソフトウェアを読んで理解し、維持することができます。 機械教育のためのプログラミング言語と類似しているのは、ラベル、機能、スキーマなど、教師の専門知識の表現です。 現在、機械教育用のプログラミング言語の標準化はありません。

貢献者の数によるスケーリングを可能にするもう1つの重要な開発は、上記で説明した問題分解の概念と密接に関連しているインターフェースおよびコンポーネント化の使用です。 コンポーネント化は、開発の複雑さを軽減する懸念の分離を可能にし、明確なインタフェースは、独立した開発と革新を可能にします。 たとえば、ソフトウェアエンジニアは、ソリューションが実行されるハードウェアの詳細を考慮する必要はありません。 機械教育では、トレーニング、サンプリング、およびフィーチャーなど、教育に必要なサービスのための明確なインターフェースの開発によって、独立した教育が可能になります。 さらに、モデル、機能、ラベル、およびスキーマのための明確なインターフェースを持つことで、これらの構成部分を構成してより複雑な問題を解決することができ、したがって問題分解でそれらを使用することができます。

貢献者の数に応じた拡張を可能にする最後の開発は、バージョン管理システムの開発です。 最新のバージョン管理システムでは、複数のソフトウェアエンジニアによる貢献の統合、投機的開発、バグ修正の分離、独自の機能開発、その他多くの利点の中で以前のバージョンへのロールバックをサポートしています。 バージョン管理システムの主な役割は、コンパイル済みバイナリを追跡するのではなく、ソースコードへの変更を追跡および管理することです。 同様に、機械教育では、バージョン管理システムがモデルの構築に使用されるラベル、機能、スキーマ、および学習者の変更の管理をサポートし、共同作業に必要なドキュメントと透明性を提供しながら実験の再現性と分岐を可能にします。

#### 3.2.3 問題解決策の開発を支援する。

過去数十年の間に、プログラミングの生産性を向上させることを目的としたツールやプロセスが急増しています。 これらには、高水準プログラミング言語の開発、統合開発環境における革新、および開発プロセスの作成が含まれます。 これらのツールやプロセスの中には、機械教育で直接の類似点があるものもあり、まだ開発および適応されていないものもあります。 表2は、これらのツールと概念の多くを機械教育にマッピングしたものです。

* プログラミング
  * コンパイラ
  * オペレーティングシステム/サービス/ IDE
  * フレームワーク
  * プログラミング言語（Fortran、Python、C＃）
  * プログラミングの専門知識
  * バージョン管理
  * 開発プロセス（仕様・単体テスト、展開、監視など）

* 機械学習
  * MLアルゴリズム（ニューラルネットワーク、SVM）
  * トレーニング、サンプリング、フィーチャーサービスなど
  * ImageNet、word2vecなど
  * ラベル、機能、スキーマなど
  * 教育の専門知識
  * バージョン管理
  * 教育プロセス（データ収集、テスト、公開など）

### 3.3 機械教育分野の軌跡

この章では、プログラミングの歴史とそれがどのように機械教育の分野の軌跡に役立つのかについて簡単に概説します。プログラミングの歴史は、コンピュータの開発と密接に関連しています。プログラミングは科学的および工学的な作業（1950年代）から始まり、FORTRANのような計算性能に焦点を合わせたプログラムやプログラミング言語はほとんどありませんでした。 １９６０年代には、管理情報システムを含むように問題の範囲が拡大し、特定のアプリケーションドメイン（例えば、ＣＯＢＯＬ）を対象とするようにプログラミング言語の範囲が拡大した。ソフトウェアエンジニアの数が急増したことで、コントリビュータによるスケーリングは困難であるという認識が生まれました[Brooks Jr 1995]。 １９８０年代には、プログラミングが適用された問題の範囲は、問題を解決するソフトウェア技術者の数が（例えば基本を用いて）したのと同様に、パーソナルコンピュータの出現と共に爆発した。最後に、1990年代になると、Webプログラミング、およびJavaScriptやJavaなどのプログラミング言語の出現により、爆発的な成長が始まりました。この文書の執筆時点で、世界のソフトウェアエンジニアの数は2,000万人に近づいています。

機械教育も同様の爆発を経験しています。 現在、機械教育の努力の多くは、機械学習と統計の専門家によって行われています。 プログラミングの話のように、機械学習が適用されている問題の範囲は拡大しています。 ２０１０年代の知覚課題（例えば、スピーチ、ビジョン、自動運転車）における深い学習の進歩により、問題を解決するために教育機械によって対処される問題の範囲を広げるための驚くべき努力がなされてきた。 ソフトウェアエンジニアの人口の増加と同様に、LUIS.ai3やWit.ai4のようなサービスの出現により、ドメインの専門家は機械学習の知識がなくても独自の機械学習モデルを構築することができました。 機械教育の分野は若く、その形成段階にあります。 この成長はさらに速いペースで続くと予想されるだけです。 事実、機械教育は、機械学習を大衆にもたらすための道であるかもしれません。

## 4 教師の役割

教師の役割は、概念を近似できる有用なモデルを生成できるように、自分の知識を学習機に移すことです。 これによって私たちが何を意味するのかを定義しましょう。

定義4.1（概念） 概念は、例のセットからラベル値のセットへのマッピングです。

たとえば、レシピWebページの概念は、Webページに調理レシピが含まれているかどうかに基づいて、ゼロまたは1を返す関数で表すことができます。 別の例では、アドレスの概念は、文書を指定すると、それぞれ「address」、「street」、「zip」、「state」などのラベルが付けられたトークン範囲のリストを返す関数で表すことができます。 バイナリの概念は、「Is」と「Is Not」です。 教師がラベリングの決定を延期したり、あいまいな例を無視したりすることを可能にする「未決定」のラベルを許可することもできます。 概念は教師の頭の中で進化しているかもしれないので、決定を延期することは重要です。 この例は[Kulesza et al。 2014]。

分類と実体抽出の両方に関して、概念定義は特徴表現から独立しているので、概念を例から概念値へのマッピングとして見るのが好きです。

定義4.2（教師） 教師は概念の知識を学習機械に移している人です。

この教師の定義を明確にするために、知識移転の方法を定義する必要があります。 この時点で、それらは、ａ）例選択（偏り）、ｂ）ラベリング、ｃ）スキーマ定義（ラベル間の関係）、ｄ）特徴付け、およびｅ）概念分解（ここで、特徴は再帰的にサブモデルとして定義される）を含む。 教師はあらゆる形態の知識移転において誤りを犯すことが予想される。 これらの「バグ」を教えることはよくあることです。

図1は、概念、ラベル、機能、および教師の関係を示しています。 すべての概念は例の表現の計算可能な関数であると仮定します。 この表現は、各例に関するすべての利用可能な情報を含むと想定されています。 横軸は例の（無限の）間隔を表します。 縦軸はプログラムまたは概念の（無限の）空間を表します。 コンピュータサイエンス理論では、プログラムとドキュメントは（長い）整数として表すことができます。 その慣習を使用して、縦軸上の各整数はプログラムとして解釈され、横軸上の各整数は文書として解釈されます。 コンパイルしないプログラムや無意味な文書は無視します。 教師が学習システムに情報を渡すためのさまざまな方法を参照するために、図1を使用します。

図1★
図1例と概念の表現 列には、特定の例のすべての概念の概念値が含まれています。 教師はその方向を見てラベルを「神」します。 教師はトレーニングセットでは利用できない機能にアクセスすることができます（それは教育力の一部です）。 しかし、先生は自分のプログラムを知りません。 概念の特徴が与えられた場合、行にはすべての例の概念値が含まれます。 教師はその方向を見て、概念の特徴の有用性を「神」にします。 教師はテストセットの分布に関する値を推測することができます（それは教育力の一部です）。 水平方向を向いている教師によって選択された機能は、過剰トレーニングの影響を受けません。

定義4.3（選択） 選択は、教師が概念の有用な側面を例示する文書へのアクセスを得るプロセスです。

教師は、ラベルなしの例のセットをフィルタリングすることによって特定の例を選択できます。 推論を使用してこれらのフィルタを慎重に選択することによって、それらは体系的に空間を探索し、概念に関連する情報を発見します。 例えば、彼らは「タンパク質の出所」に関する質問を出すことによってレシピ分類子を構築している間に昆虫レシピを発見するかもしれません。 一様サンプリングまたは不確実サンプリングは教師の介入も意味論的意味も持たず、前向きな例のまれなクラスタを発見するのには役立たない。 訓練されたモデルを含む意味フィルタの組み合わせはさらに強力である（例えば、「栄養タンパク質」および現在の分類子による低いスコア）。 概念の有用な側面を含む例を見つけるこの能力は、教師が有用な特徴を見つけることを可能にし、それらを訓練するためのラベルを提供します。 ラベルや機能がなくても、選択例には概念を文書化した教師の偏りが含まれており、想起を改善するために使用できます。

定義4.4（ラベル） ラベルは、概念に関連して教師によって作成された（文書、概念値）ペアです。

教師は、図1の「列を見る」ことでラベルを付けることができます。目標概念の値を評価するために、教師は自分の頭の中でどのプログラムが実行されているのかわからないことを認識してください。 彼らがプログラムを知っていれば、彼らはプログラムの形で知識を機械に移すでしょうし、機械学習は必要ないでしょう。 代わりに、教師は例の利用可能なデータを調べ、そのラベルを「神聖」にします。 彼らは、無意識にサブ機能を評価し、それらを組み合わせてラベリングを決定することによってこれを行います。 教師に利用可能な特徴空間および組み合わせ機能は、訓練セットを通して利用可能なものを超えている。 この力こそが、教師がラベルを作成するのに価値のあるものにするものです。

定義4.5（スキーマ） スキーマは概念間の関係グラフです。

複数の概念が関係している場合、教師はそれらの間の関係を表現することができます。 例えば、教師は、概念「テニス」と「サッカー」が互いに排他的であること、またはその概念「テニス」が概念「スポーツ」を暗示していると表現することができる。 これらの概念制約は、ダイアグラム上の線の間の関係です（すべての例で共通です）。 スキーマによって捉えられた知識をラベルによって捉えられた知識から分離することは、情報が高レベルで伝達され編集されることを可能にする。 暗黙のラベルは、概念の関係を変更するだけで変更できます。 例えば、「ゴルフ」は「スポーツ」のサブコンセプトであることから相互に排他的であること、またはその逆に移動することができます。 教師は、スキーマを見直すことで概念の意味を理解し、変更することができます。 意味的な決定は、個々のラベルを編集せずに元に戻すことができます。

定義4.6（機能） 特徴は、各例にスカラー値を割り当てるシステムで利用可能な概念関数です。

一般的な機能は、パラメータ化可能な形式でエンジニアによって作成され、教師は有用で意味的なパラメータを提供することによってそれらを具体化します。たとえば、一般的な機能は「Log（1 +文書内のリストX内の単語のインスタンス数）」であり、そのインスタンス化によってXが自動車ブランドのリストになることがあります（自動車用クラシファイアに役立ちます）。教師は、図1の水平線を見て、機能（サブコンセプト）を選択することができます。2つのサブコンセプトがある場合、ラベリングされていない大規模なセットでは、一方が他方より優れていると判断できます。例えば、彼らは、単語「the」の存在を測定する特徴よりも「recipe」という単語の存在を測定する特徴を選択することができるが、後者の特徴はトレーニングセットに対してより良い結果をもたらす。テストセットの推定分布に基づいて特徴の値を推定するこの機能は、おそらく教師にとって最も有用な機能です。機能エンジニアリングは不可欠です。このようにして教師によって選択された機能は、トレーニングセットから独立しているため、過剰トレーニングの影響を受けません。トレーニングセットと概念に依存しない統計のみを見る、この非常に異なる形式の「自動機能選択」。自動特徴選択は過剰訓練の影響を非常に受けやすい。

定義4.7（分解） 分解は、より単純な概念を使用してより複雑な概念を表現することです。

教師は自分の概念を実行するプログラムに直接アクセスすることはできませんが、彼らは時々彼らがどのように働くかを推測することができます。 ソクラテスはかつて正しい質問をすることによって教えていました。 「正しい質問」は有用なサブ概念を提供することに似ています。その価値は概念全体を評価することをより簡単にします。 言い換えれば、ソクラテスは例ではなく分解によって教えていました。 この能力は教師にとって等しく利用可能ではありません。 それは学ばれます。 複雑さを増し、教師の数を増やして拡張することが不可欠です。 ソフトウェアエンジニアが機能をサブ機能に分解するのを助けるのと同じ能力です。 ソフトウェアエンジニアも経験を積んでこの能力を身に付けます。 プログラミングのように、分解を教えることはユニークではありません（ソフトウェア工学では、ある分解から別の分解への切り替えはリファクタリングと呼ばれます）。

概念分解を通して教師によって提供される知識は、高水準でモジュール式です。 各概念の実装は、独自の例の選択、ラベル、スキーマ、および機能を提供します。 これらは、インターフェースと契約の文書化と見なすことができます。 各概念の実装はブラックボックスかもしれませんが、概念の階層は透明で解釈可能です。 概念分解は、教師によって提供される最高レベルの知識です。

（機械）教師の重要な役割のいくつかを定義したので、これらの教師が誰であるかという問題に目を向けます。

### 4.1 教師は誰とどこですか？

私たちは、学習システムとの対話型の情報交換に関与している人の文脈における教師の概念に興味を持っています。 私たちはこのレンズを使って、私たちが想像しているような教えることが起こらないプロセスや、それらを定義するような教師が必要とされないプロセスを識別します。

上記の事例には、利用可能なデータにラベルが付けられ、豊富で、事実上無限であると認識されることが多い問題が含まれます。 コンピュータビジョン、音声理解、ゲノミクス分析、クリック予測、財務予測などの問題分野では、教師はボトルネックにはなりません。 強力な学習アルゴリズムまたはハードウェアは、望ましいパフォーマンスを備えたソリューションを実現するための優れた戦略です。 多数のラベルがある場合は、クロスバリデーションを使用した機能選択を使用して、関係する機械教師を必要とせずに優れた解決策を得ることができます。

対話型ティーチングループが意味を成す現在のケースでは、それは上のセクションで説明したようなプロセスに従って行われます。 機械学習ソリューションの開発を取り巻く今日のプロセスは、データサイエンスや機械学習に非常に近い、またはその分野の専門家によって形成されています。 言い換えれば、今日の機械学習ソリューションを構築するための訓練を受けている新しい実務者は、現在のプロセスの影響を受けて形成されています。

これらのプロセスの中で、データサイエンティストは教師の役割に最も近い人々です。 彼らは主にラベル付きデータが豊富な問題に取り組み、それを理解するために彼らの専門知識を適用し、そしてそれを使用可能な形式に変換します。 データ科学者は新しいアルゴリズム（機械学習の専門家の範囲）を作成しませんが、より良い結果を得るために既存のものを微調整できます。 データサイエンティストはまた、問題の所有者と対話する範囲でドメイン知識を提供し、データのどの面および機能が重要かどうかを識別します。 この点について、私たちは、データが有用であると人が解釈する必要がないのであれば、機械学習は必要ないと主張します。

機械教育が不要な場所を知ることで、機械教育が最も大きな影響を与える可能性があるプロセスと問題を認識することができます。 データが豊富で、ラベルが付けられていない、または概念を明確にするためのドメイン知識が不可欠である場合、多くの問題があります。 これらの例としては、口頭での対話や環境のコンテキストを介したモノのインターネットアプライアンスの制御、新興企業の新製品に関するお客様からのフィードバックの適切な部門へのルーティング、100回にわたるパラリーガルシフトを支援するワンタイムアシスタンスの構築などがあります。 何千というブリーフなど

この新世代の機械教師は、ドメインエキスパートの範疇にあります。 この新しい世代を定義する重要な属性は、問題のセマンティクスを理解する能力、概念の例と反例を生み出す能力、そしてそれらの違いを（機械教育言語を通して）明確に表現できることです。 ドメインエキスパートは、機械学習やデータサイエンスのコミュニティよりも数桁大きいです。 私たちはソフトウェアエンジニアと同じ数の機械教師に到達することを目指しています。 表3は、機械学習の科学者、データサイエンティスト、およびドメインの専門家の数の違いを示しています。

ドメインエキスパートが教えることを可能にすることは、私たちが今まで見たことのない規模で、何百万という意味のある、個人的な、共有された、「一度限りの」そして繰り返し起こる問題を直接解決するための知識を応用する能力を開きます。

* Potential teacher
  1. 機械学習のエキスパート
  2. データサイエンティスト/アナリスト
  3. ドメインエキスパート
* 規模
  1. 何万
  2. 何十万
  3. 数千万
* 特徴
  1. 機械学習について深く理解している。 パフォーマンスを向上させるために機械学習アルゴリズムまたはアーキテクチャを変更できます
  2. 機械学習を使用してビッグデータを分析し、傾向と相関を検出できます。 機械学習モデルを既存の価値についてトレーニングして、ビジネスの価値を引き出すことができます。
  3. 問題の意味を理解します。 例と反例を提供し、それらの違いを説明できます。

## 5 教育プロセス

教育用言語またはプログラミング言語は、さまざまな方法で適用できます。他の方法よりも効果的な方法もあります。 私たちが教える過程について話すとき、私たちは機械教育言語がどのように適用されるか、そして有用で満足のいく結果を得るために従うパターンと原則が何であるかについて言及します。 特に、以下の機械教育原則を提案します。

***普遍的な教育言語：***

私たちは特定の機械学習アルゴリズムの力に頼っていません。 ティーチングインタフェースはすべてのアルゴリズムで同じです。 機械学習アルゴリズムが別のものと交換された場合、さらに教育が必要になるかもしれませんが、教育言語とモデル構築の経験は変わりません。 機械学習アルゴリズムは交換可能であるべきです。 逆に、教育言語は、その分野（例えば、テキスト、信号、画像）を考慮すると、単純で習得が容易であるべきである。 理想的には、ドメインごとにANSIまたはISO規格を設計することを目指しています。 同じ言語を話す教師たちは交換可能であるべきです。

**機能の完成度**

教師が利用できる機能言語は「機能完了」であると仮定します。 これは、教師が実装したいと思う可能性のあるすべてのターゲット概念が、モデルと機能の再帰的構成によって「実現可能」であることを意味します。 機能の完全性は、教師ではなくシステムをインストールするエンジニアの責任です。 教師は以下の行動で概念を実現可能にすることができます。

* （1）教師が2つの異なるクラスに属する2つのパターンを意味のある方法で区別できる場合、同等の意味のある区別をすることができる機能が利用可能でなければなりません。 これは、機械学習から機械を切り離すというセクションで説明した最初の要件です。 そのような特徴を追加することによって、教師は特徴盲目の誤りを修正することができます。

* （２）概念関数が、その特徴セットについて現在利用可能な関数のクラスに属さない場合（例えば、特徴が与えられた場合、概念は非凸面であり、トレーニングは特徴空間の凸関数のみを返す）、教師は追加することができる。 概念関数が含まれるまで関数空間を増やす機能。 これは、機械学習のセクションから機械を切り離すことで説明されている2番目の要件です。 追加された機能は、（独自のトレーニングセットと機能を持つ）トレーニング済みモデルにすることができます。 これは容量不足から生じるエラーを修正します。

* （3）あいまいなパターンや、機能言語以外の機能を必要とするパターンは、機能、ラベル、および教師が困難な例に費やす時間を無駄にしないように「気にしない」としてマークできます。 「ドントケア」の領域は、ベイズエラー率にもかかわらず実現可能性の仮定を維持するための対処メカニズムとして使用されます。

**準無限サンプリング集合**

いつでも、教師はターゲット（またはデプロイメント）ディストリビューションから一見無限の量のデータにアクセスできます。ラベル付けされることになっているデータのみを収集するという考えは時代遅れです。ラベルのないデータは、消防用ホースを通して収集する必要があります。データを保存する費用は、教える費用と比較してごくわずかです。準無限の量のデータを持つことで、教師は前のセクションで説明したように選択を通して知識を表現するためにそれを探索することができます。それはまた、教師が元の概念よりも具体的な下位概念を訓練するために使用できる例を見つけることを可能にします。例えば、教師は、盆栽園芸（下位概念）および植物園芸（除外概念）のための分類子を園芸分類子への特徴として使用するために構築することを決定することができる。大きなサンプリングセットにより、教師はサブコンセプトに対応する分類子を訓練するのに十分な正と負の例を見つけることができます。理想的には、サンプリングセットはターゲット分布と一致する必要があります。これは展開の驚きを奪います。サンプリングセットはエンジニアが追加したり、回転させたりすることもできます（FIFO）。ラベルは常にいくつかの意味的価値を保持しているので、教師によってラベル付けされた例は永遠に保たれます。警告：サンプリングセットのキュレーションは危険な場合があります。

**分布の頑健性**

トレーニングセットはテスト分布と一致する必要はないと仮定します。 これにより、教師は前のセクションで説明したように、予約なしに選択を通じて知識を表現することができます。 概念が実現可能であるため、この仮定は可能です。 教師の役割はモデルを作成することです（コンセプト
実装）は、分布に関係なく、空間全体にわたって正しいです。 「ソート」関数のプログラミングを想像してください。 ソートするデータの分布に関係なく、 "ソート"が機能することを期待しています。 私たちは教えることについても同じ正確さを期待しています。 トレーニングデータは、フィルタリングを使用してアドホックな方法でトレーニングセットに対して発見されラベル付けされるので、分布の頑健性は重要な仮定である。 警告：分布の頑健性の仮定は評価を複雑にします。 従来の機械学習評価に使用された例は、異なる方法で収集する必要があります。 共変量シフトに対してロバストな機械学習アルゴリズムを推奨します。

**概念のモジュール性**

概念はインターフェースと見なされます。機能、ラベル、およびスキーマがインタフェースを文書化します。インターフェース継承への類似は、機能として使用されるスキーマと概念に由来します。ラベルはプログラミングユニットテストに似ています。概念の実装は「プロジェクト」を通じて行われます。再現性と単純さを最大にするために、プロジェクトは関数型プログラミングパラダイムに従います。プロジェクトは「ソリューション」（またはワークスペース）に分類されます。制約条件および直接的な依存関係（例えば、局所的に進化する機能概念、相互に排他的なクラス）によって束縛される概念のためのプロジェクトは、同じ解決策の中に存在しなければならない。ソリューション内のプロジェクトは一緒にトレーニングされます（再トレーニングは互いに影響を与える可能性があるため）。関数型プログラミングパラダイムに従い、ソリューションとワークスペース全体の依存関係は、バージョン管理されたパッケージとして扱われます。あるソリューションでプロジェクトを撤回しても、新しいバージョンが別のソリューションから教師によって意図的に引き出されない限り、別のソリューションでプロジェクトに影響を与えることはありません。警告：モジュール性の原則は隠れた表現の共有を除外しています6。表現の共有は、概念インタフェースを通じて明示的に行わなければなりません。

```
[Algorithm 1: A machine teaching process]
repeat
    while トレーニングセットが実現可能である
        if 品質基準が満たされている
            exit
        end
        \\概念ベースのフィルタを使用してサンプリングセットを積極的かつ意味的に探索します。

        テストエラー（すなわち、誤って予測された（例、ラベル）のペア）を見つける。
        例をトレーニングセットに追加します。
    end
    \\トレーニングセットエラーを修正
    if トレーニングエラーがラベリングエラーによって引き起こされている
        ラベリングエラーを修正してください。
    else
    \\機能の盲目を修正しました。 これには、次のうち1つ以上のアクションが含まれる可能性があります。

    基本機能を追加または編集します。
    新しい機能のための新しい概念/プロジェクトを作成する（分解）。
    ラベルの制約やスキーマを変更する（高度な知識）
    end
untile ずっと;
```

**バージョン管理**

すべての教師の行動（例えば、ラベル、機能、ラベル制約、スキーマおよび依存関係グラフ、さらに必要に応じてプログラミングコードさえも）は、概念「プログラム」と等価である。 それらは同じ「コミット」に保存されます。 プログラミングコードと同様に、概念に関連する教師の行動はバージョン管理システムに保存され、教師の貢献のサイズは行動の数に比例し、異なる種類の行動は異なるファイルに保存され、別の教師の投稿間のマージ操作が容易になります。 

これらの原則の組み合わせは、標準的な教育プロセスとは異なる教育プロセスを示唆しています。機械学習の不可知論は、機械学習の専門家がループから外れることを意味します。実現可能性（または完全性を特徴とする）の仮定は、エンジニアが同様に教育のループから除外されることを意味します。エンジニアはデータパイプラインとプログラミング言語を更新することができますが、どちらも概念に依存しないため、エンジニアは教示のループに入っていません。これら2つの原則は、ドメインと教育の知識を持つ一人の人がプロセス全体を所有できることを意味します。準無限サンプリング集合が利用可能であることは、データ収集ステップが概念教育プロセスの一部ではないことを意味します。分散ロバスト性の原則により、教師はクラスや例のタイプのバランスを心配することなく、プロセス全体を通して自由に調査しラベルを付けることができます。概念のモジュール性とバージョン管理により、プロジェクト内で作成された機能は、その機能のすべてが確定的であり、トレーニングが確定的である場合に再現可能であることが保証されます。概念のモジュール性の原則は、解釈可能性と複雑さを伴うスケーリングを可能にします。解釈可能性は、ラベル、機能、またはスキーマを見ることによって、各サブコンセプトの機能を説明できることからきています。各サブコンセプトがブラックボックスで囲まれていても、それらのインターフェースは透明です。バージョン管理のマージ機能により、複数の教師間のコラボレーションが簡単になります。

上記に基づいて、我々はアルゴリズム１における教示プロセスのためのスケルトンを提案する。このプロセスは独特ではないことに注意されたい。 分布に強い設定で品質基準を評価することは困難であり、このホワイトペーパーの範囲を超えています。 簡単な基準としては、教師の費用や時間が一定の限度に達したときに一時停止することが考えられます。 テストエラーを効果的に見つけることも困難であり、このホワイトペーパーの範囲を超えています。 アイデアは、教師固有のクエリで作成された概念とサブ概念を利用して大規模なサンプルセットを検索することです。 技術は、問い合わせの意味的表現力と結果の多様性を最大限にすることです。 不確実性サンプリングは些細で興味をそそるケースです（あいまいな例は新しい分解概念を思いつくために役に立ちません）。

上記の教育プロセスと標準的なモデル構築プロセスとの間には、いくつかの大きな違いがあります。 最も重要な側面は、それが本当のディストリビューションを操作している単一のアクターによって行われることができるということです。 教師から学習者への知識の伝達には複数の様相（選択、ラベル、機能、制約、スキーマ）があります。このプロセスは、Tom MitchellのNELLを彷彿とさせる終わりのないループです[Carlson et al。 2010]。 彼らのNELLシステムは、トレーニングセット上で常にゼロエラーの状態にあります。 キャパシティはオンデマンドで増加するので、教師は必要なときにだけ機能を追加することによって学習システムのキャパシティを制御するので、従来の正規化の必要はありません。

## 6 結論

過去20年にわたり、機械学習の分野では、学習アルゴリズムの開発と完成に全力を尽くしてきました。データが豊富で統計的な保証が十分である問題のために、このアプローチは功を奏しています。この分野は現在、はるかに多くの単純でより短期間の問題に対処する方向に進化しています。これらの問題を解決する需要が効果的に高まる一方で、対応するソリューションを構築できる教師へのアクセスは、その不足とコストによって制限されています。この需要を本当に満たすためには、対応する科学を進歩させる必要があります。この変化は、1980年代と1990年代のプログラミング分野の変化と同じです。これと並行して、さまざまなメリットが得られます。この論文はプログラミングの歴史から3つの教訓からインスピレーションを得ています。 1つ目は問題の分解とモジュール化であり、これによりプログラミングを複雑に拡張することができました。私たちは、同様のアプローチが機械教育にも同じ利点があると主張します。 2番目のレッスンは、プログラミング言語の標準化です。一度書いて、どこでも実行できます。この論文は標準的な機械教育言語を提案していない、しかし我々は教師に利用可能な最も重要な譲渡可能な、機械学習不可知論的な知識チャンネルを列挙した。最後のレッスンは、関心事の分離、および標準的なツールとライブラリの構築を含むプロセスの規律です。これは生産性とスケーリングに対する同じ制限を、プログラミングを悩ませた貢献者の数とともに解決します（ "Mythical Man Month" [Brooks Jr 1995]で説明されているように）。私たちはより良い教育プロセスの規律につながる一連の原則を提案しました。バージョン管理などのプログラミングツールの一部はそのまま使用できます。これらの原則のいくつかは、LUIS.aiなどのサービスや、Bing LocalなどのMicrosoft内の製品グループによって正常に適用されています。私たちは、教育対話型開発環境を構築する初期段階にあります。

より哲学的な注意を払って、ディープラーニングによって要約されるように、大きなモノリシックシステムは、人工知能における一般的な傾向です。これを機械学習行動主義の一種と見なしています。複雑な概念は常に（入力、出力）ペアだけから学ぶことができるという考えです。教師なし学習を使用して、作業を容易にするために深い表現（より高い形式の入力）を作成できます。教師なし学習を使用した結果が概念の定義より前に計算された場合でも、概念固有の学習は依然として（入力、出力）ペアだけから行われます。このアプローチは、技術的にはまだ行動主義であるため、関数カウントの観点からは疑わしいです。入力が一連の単語である場合、それらを一般化するのに十分なペアを列挙するのは宇宙の年齢よりも長い時間がかかるため、（入力、出力）ペアからシェークスピアの高品質プレイを書くことはできません。行動主義的アプローチを使用してタスクが実行可能な表現があると主張するかもしれませんが、その表現はどこから来るのでしょうか。もしそれが概念に依存しないのであれば、それはカウントの議論を通らない。それが概念に依存しているならば、それは分解される必要がありますか？データの場所（ラベル付きまたはラベルなし）を最適化して深い表現を構築した場合、表現不足の概念に対して有用な表現が提供されると期待できますか。大規模モノリシックシステムは非常に便利ですが、そのようなシステムがすべての問題を解決できるとは考えにくいです。

対照的に、その概念をサブ概念に分解する能力と才能を持つ教師でどの概念を学ぶことができるかという複雑さの限界を予測するのは困難です。プログラミングのたとえが成り立つならば、Church-Turingの論文はその限界を示唆している。おそらく、知性の出現は優れたアルゴリズムからではなく教えることによって引き起こされたのかもしれません。しかし、Evolutionは教えることになると障害があります。それは学習者の観点からしか最適化できません。先生は直接教えることから恩恵を受けません。それは、選択が、教育から最大限の利益を得るために、貧しい教師に頑健性を構築しなければならないことを意味します。そのメカニズムは存在する：子供たちが進歩するには単純すぎる（十分に構成されていない）または複雑すぎる（十分に分解されていない）概念があるとき、彼らは彼らの教師に知らせる方法がある。その意味で、彼らは教育の質をコントロールしています。このメカニズム（例えば、子供が行動を起こす）は、明らかに、長年などの長期間にわたって教えるのに十分な指導を両親に与えていない。 Jean Piagetは、子供たちが段階的に学ぶことを理論化しました（ピアジェの認知発達論）。これは明らかに包括的な学習アルゴリズムの一部です。学習者は私たちが理解できない方法で最適化されるかもしれません。しかし、この取り決めが両親を教えることに大きな影響を与えることを言及する価値があります。学習段階や子供たちが教えることを指導しなければ、良い親教師になることは恐ろしいことです。 Evolutionは、貧弱な教育に対する堅牢性を保証するための組み込みメカニズムを作成しました。明白な理由から、「教師の頑健性」は機械教育の長期的な追求です。それは人工知能にとって不可欠な要素かもしれません。

以上

---

* 参照
  * https://www.microsoft.com/en-us/research/wp-content/uploads/2017/07/machine-teaching.pdf